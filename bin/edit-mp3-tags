#!/usr/bin/env perl
use warnings;
use strict;

# use open IO => ":locale";
use open IO => ":encoding(UTF-8)";

use Getopt::Long;

our $verbose = 0;
our $dry_run = 0;
our $force = 0;
our $parse_filenames = 0;

Getopt::Long::Configure("bundling", "gnu_compat");
Getopt::Long::GetOptions(
    "v|verbose+"        => \$verbose,
    "n|dry-run"         => \$dry_run,
    "f|force"           => \$force,
    "p|parse-filenames" => \$parse_filenames,
    "h|help" => sub { usage(); exit(0); }
) or die("Type '$0 --help' for help.\n");

sub usage { print(<<"END"); }
usage:
  edit-mp3-tags [OPTION ...] MP3FILE ...
options:
  -h, --help
  -p, --parse-filenames
  -v, --verbose
  -n, --dry-run
  -f, --force
END

if (scalar(@ARGV)) {
    my $editor = My::MP3::TagEditor->new();
    $editor->{verbose}         = $verbose;
    $editor->{dry_run}         = $dry_run;
    $editor->{parse_filenames} = $parse_filenames;
    $editor->{force}           = $force;
    $editor->run(@ARGV);
} else {
    warn("No files specified.  Exiting.");
    exit(1);
}

package My::MP3::TagEditor {

    use MP3::Tag;
    use File::Temp qw(tempfile);
    use Data::Dumper;
    use Text::ParseWords;
    use Text::Trim;
    use File::Which;

    sub new {
        my ($class) = @_;
        my $self = bless({}, $class);
        return $self;
    }

    sub run {
        my ($self, @filenames) = @_;
        $self->load_tags_from_files(@filenames);
        $self->fix_track_numbers($self->{tracks});
        $self->create_tags_file_to_edit();
        $self->edit_tags_file();
        $self->load_tags_from_tags_file();
        $self->fix_track_numbers($self->{edited_tracks});
        if ($self->{modified} || $self->{dry_run} || $self->{force}) {
            $self->save_tags();
        }
    }

    INIT {
        MP3::Tag->config("prohibit_v24" => 0);
        MP3::Tag->config("write_v24" => 1);
    }

    sub fix_track_numbers {
        my ($self, $track_array) = @_;
        foreach my $track_hash (@{$track_array}) {
            my $track = $track_hash->{track};
            if ($track =~ m{^\s*(\d+)\s*(?:of|/)\s*(\d+)\s*$}i) {
                $track_hash->{track_no} = $1 + 0;
                $track_hash->{track_of} = $2 + 0;
            } elsif ($track =~ m{^\s*(\d+)\s*$}i) {
                $track_hash->{track_no} = $1 + 0;
                $track_hash->{track_of} = undef;
            }
        }
        my $sorted_track_numbers = join(",", sort { $a <=> $b } map { $_->{track_no} // 0 } @{$track_array});
        my $check_track_numbers  = join(",", 1 .. scalar(@{$track_array}));
        if ($sorted_track_numbers eq $check_track_numbers) {
            @{$track_array} = sort { $a->{track_no} <=> $b->{track_no} } @{$track_array};
            foreach my $track_hash (@{$track_array}) {
                $track_hash->{track_of} = scalar(@{$track_array});
                $track_hash->{old_track} = $track_hash->{track};
                $track_hash->{track} = sprintf("%d/%d", $track_hash->{track_no}, $track_hash->{track_of});
            }
            if (grep { $_->{track} ne $_->{old_track} } @{$track_array}) {
                $self->{modified} = 1;
            }
        }
    }

    sub load_tags_from_files {
        my ($self, @filenames) = @_;
        $self->{tracks} = [];
        foreach my $filename (@filenames) {
            next unless $filename =~ m{\.mp3$}i;

            my $mp3 = MP3::Tag->new($filename);
            if (!defined $mp3) {
                warn("edit-mp3-tags: could not read tags for $filename\n");
                next;
            }

            my ($title, $track, $artist, $album, $comment, $year, $genre) = $mp3->autoinfo();
            my $album_artist = $mp3->select_id3v2_frame_by_descr("TPE2"); #"Band/orchestra/accompaniment"
            my $tcmp         = $mp3->select_id3v2_frame_by_descr("TCMP"); # iTunes Compilation Flag

            if ($track =~ m{^\s*(\d+)\s*(?:of|/)\s*(\d+)\s*$}) {
                my $track_num    = $1;
                my $track_num_of = $2;
                my $new_track_num    = $track_num + 0;
                my $new_track_num_of = $track_num_of + 0;
                my $new_track = "${new_track_num}/${new_track_num_of}";
                if ($new_track ne $track) {
                    $track = $new_track;
                    $self->{modified} = 1;
                }
            } else {
                my $new_track = $track + 0; # "01234" => 1234
                if ($new_track ne $track) {
                    $track = $new_track;
                    $self->{modified} = 1;
                }
            }

            my $track_hash = {
                title        => $title,
                track        => $track,
                artist       => $artist,
                album        => $album,
                comment      => $comment,
                year         => $year,
                genre        => $genre,
                album_artist => $album_artist,
                tcmp         => $tcmp,
                filename     => $filename,
            };

            if ($self->{parse_filenames}) {
                if ($filename =~ m{^(?:(\d+)(?:\s*-+\s*|\s*\.\s*))?(.*?)(?:\s*-+\s*)(.*?)(?:\.mp3)?$}xi) {
                    my ($new_track, $new_artist, $new_title) = ($1, $2, $3);
                    if (defined $new_track && $new_track =~ m{\S}) {
                        $track_hash->{track} = $new_track;
                        $track_hash->{modified} = 1;
                        $self->{modified} = 1;
                    }
                    if (defined $new_artist && $new_artist =~ m{\S}) {
                        $track_hash->{artist} = $new_artist;
                        $track_hash->{modified} = 1;
                        $self->{modified} = 1;
                    }
                    if (defined $new_title && $new_title =~ m{\S}) {
                        $track_hash->{title} = $new_title;
                        $track_hash->{modified} = 1;
                        $self->{modified} = 1;
                    }
                }
            }
            push(@{$self->{tracks}}, $track_hash);
        }
    }

    sub create_tags_file_to_edit {
        my ($self, @filenames) = @_;
        if (scalar @{$self->{tracks}}) {
            my ($fh, $tempname) = tempfile();
            $self->{tempname} = $tempname;
            print $fh "# Lines starting with '#' are ignored.\n";
            print $fh "# Un-comment the following line for various-artists compilations.\n";
            print $fh "#various-artists\n";
            print $fh "# Un-comment any of the following line(s) for albums.\n";
            print $fh "#artist=<artist>\n";
            print $fh "#album=<album>\n";
            print $fh "#year=<year>\n";
            print $fh "# Make changes, save, and exit your editor to effect your changes.\n";
            print $fh "# Blank out this file to cancel all changes.\n";
            print $fh "\n";
            my $column_width = 32;
            foreach my $track (@{$self->{tracks}}) {
                printf $fh ("%8s. ",              $track->{track});
                printf $fh ("artist=%-*s",        $column_width, $track->{artist});
                printf $fh ("|title=%-*s",        $column_width, $track->{title});
                printf $fh ("|album=%-*s",        $column_width, $track->{album});
                printf $fh ("|year=%-*s",         $column_width, $track->{year});
                printf $fh ("|album-artist=%-*s", $column_width, $track->{album_artist} // "");
                printf $fh ("|filename=%s",       $track->{filename} // "");
                print  $fh "\n";
            }
            $self->{tempname_mtime} = (stat($tempname))[9];
        } else {
            warn("No tracks.  Exiting.\n");
            exit(0);
        }
    }

    sub edit_tags_file {
        my ($self) = @_;
        my $editor = $ENV{VISUAL} // $ENV{EDITOR} //
            which('nano') // which('pico') // which('vi');
        if (!$editor) {
            die("Can't figure out what editor you want to use.\n".
                    "You don't have VISUAL or EDITOR specified and\n".
                    "you don't have nano, pico, or vi.\n");
        }
        my @editor = shellwords($editor);
        my $result = system(@editor, $self->{tempname});
        my $mtime = (stat($self->{tempname}))[9];
        if ($result) {
            $self->editor_failed();
        } else {
            if ($mtime != $self->{tempname_mtime}) {
                $self->{modified} = 1;
            }
        }
        if (!$self->{modified}) {
            if (!$self->{force} && !$self->{dry_run}) {
                $self->not_modified();
            }
        }
    }

    sub editor_failed {
        my ($self) = @_;
        warn("Editor failed.  Exiting.\n");
        unlink($self->{tempname});
        exit(1);
    }

    sub not_modified {
        my ($self) = @_;
        warn("Not modified.  Exiting.\n");
        unlink($self->{tempname});
        exit(0);
    }

    sub load_tags_from_tags_file {
        my ($self) = @_;
        my $tempname = $self->{tempname};
        my $fh;
        open($fh, "<", $tempname) or die("Cannot read $tempname: $!\n");
        $self->{album} = {};
        my $last_line_album = 0;
        my $last_line_track = 0;
        $self->{edited_tracks} = [];
        local $. = 0;
        while (<$fh>) {
            next if m{^\s*\#};  # ignore comments;
            s{\R\z}{};          # safer chomp
            next unless m{\S};  # skip blank lines
            if (!m{\|}) {
                if (!$last_line_album) {
                    warn("album hash: emptying.\n");
                    $self->{album} = {};
                }
                s{^\s+}{};
                s{\s+$}{};
                if (m{\s*=\s*}) {
                    my ($key, $value) = ($`, $');
                    $key =~ s{-+}{_}g;
                    warn("album hash: $key = $value\n");
                    $self->{album}->{$key} = $value;
                } else {
                    s{-+}{_}g;
                    warn("album hash: $_ = 1\n");
                    $self->{album}->{$_} = 1;
                }
                $last_line_album = 0;
                $last_line_track = 1;
                next;
            }
            my $track_hash = {
            };
            if (s{^\s*(\d+)(?:\s*(?:/|of)\s*(\d+))?\s*\.\s*}{}i) {
                my ($track_number, $track_number_of) = ($1, $2);
                if (defined $track_number_of) {
                    $track_hash->{track} = sprintf("%s/%s", $track_number, $track_number_of);
                } else {
                    $track_hash->{track} = $track_number;
                }
            }
            my @kv = split(/\|/, $_);
            foreach (@kv) {
                s{^\s+}{};
                s{\s+$}{};
                if (m{\s*=\s*}) {
                    my ($key, $value) = ($`, $');
                    $track_hash->{$key} = $value;
                } else {
                    $track_hash->{$_} = 1;
                }
            }
            push(@{$self->{edited_tracks}}, $track_hash);
            if ($self->{verbose} >= 3) {
                warn Dumper($track_hash);
            }
        }
    }

    sub save_tags {
        my ($self) = @_;

        foreach my $track_hash (@{$self->{edited_tracks}}) {
            my $filename = $track_hash->{filename};
            if (!defined $filename || $filename !~ m{\S}) {
                warn("No filename on $filename line $.\n");
                next;
            }

            my $track    = $track_hash->{track};
            my $artist   = $self->{album}->{artist} // $track_hash->{artist};
            my $title    = $track_hash->{title};
            my $year     = $self->{album}->{year}   // $track_hash->{year};
            my $album    = $self->{album}->{album}  // $track_hash->{album};

            my $album_artist;
            if ($self->{album}->{variousartists}) {
                $album_artist = $artist;
                $artist = "Various Artists";
            }

            my $mp3 = MP3::Tag->new($filename);
            if (!defined $mp3) {
                warn("edit-mp3-tags: could not read tags for $filename\n");
                next;
            }
            if ($self->{verbose} >= 2 || ($self->{dry_run} && $self->{verbose})) {
                printf("%s\n", $filename);
                printf("  TRACK        = %s\n", $track        // "");
                printf("  ARTIST       = %s\n", $artist       // "");
                printf("  TITLE        = %s\n", $title        // "");
                printf("  ALBUM        = %s\n", $album        // "");
                printf("  YEAR         = %s\n", $year         // "");
                printf("  ALBUM_ARTIST = %s\n", $album_artist // "");
            }
            if (!$self->{dry_run}) {
                $mp3->title_set($title // "", 1);
                $mp3->artist_set($artist // "", 1);
                $mp3->year_set($year // "", 1);
                $mp3->album_set($album // "", 1);
                $mp3->track_set($track // "", 1);
                if ($self->{album}->{variousartists}) {
                    $mp3->select_id3v2_frame_by_descr("TPE2", $album_artist);
                    $mp3->select_id3v2_frame_by_descr("TCMP", "1");
                } else {
                    $mp3->select_id3v2_frame_by_descr("TPE2", undef);
                    $mp3->select_id3v2_frame_by_descr("TCMP", undef);
                }
                if ($self->{verbose}) {
                    warn("Updating tags on $filename\n");
                }
                $mp3->update_tags();
            }
            if ($self->{verbose} && !$self->{dry_run}) {
                print("Done.\n");
            }
        }
    }
};
